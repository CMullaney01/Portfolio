/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { a } from "@react-spring/three"
import ObeliskCircle from './ObeliskCircle'; // Import the ObeliskCircle component
import fabric from '../assets/textures/splodges.png'
import * as THREE from "three";


import islandScene from '../assets/3d/IslandV7.glb'
import { NightSky } from "./Stars";

// preload = useGLTF.preload(islandScene)
// Preload texture
const textureFabric = new THREE.TextureLoader().load(fabric);

const fabricMat = new THREE.MeshStandardMaterial({
    map: textureFabric,
    roughness: 0,
    metalness: 1
});


const Island = ({ isRotating, position, setIsRotating, setCurrentStage, obeliskRotation, obeliskScale, obeliskRadius, isPanelView, setIsPanelView, finishedRotating, setFinishedRotating, ...props })  => {
    const islandRef = useRef();
    // Get access to the Three.js renderer and viewport
    const { gl, viewport } = useThree();
    const { nodes, materials } = useGLTF(islandScene);

    // Use a ref for the last mouse x position
    const lastX = useRef(0);
    // Use a ref for rotation speed
    const rotationSpeed = useRef(0);
    // Define a damping factor to control rotation damping
    const dampingFactor = 0.95;

    const lastPanelState = useRef(true)
    // Handle pointer (mouse or touch) down event
    const handlePointerDown = (event) => {
        event.stopPropagation();
        event.preventDefault();
        setIsRotating(true);
        setFinishedRotating(false);


        // Calculate the clientX based on whether it's a touch event or a mouse event
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;

        // Store the current clientX position for reference
        lastX.current = clientX;

        // Store the current isPanelView state for reference
        lastPanelState.current = isPanelView;

        // Set isPanelView to false
        setIsPanelView(false);
    };

    // Handle pointer (mouse or touch) up event
    const handlePointerUp = (event) => {
        event.stopPropagation();
        event.preventDefault();
        setIsRotating(false);

        // Revert to the last panel state
        setIsPanelView(lastPanelState.current);
    };

    // const throttledHandlePointerMove = throttle(handlePointerMove, 16); // Adjust the throttle time as needed (e.g., 16ms for 60fps)

    // Handle pointer (mouse or touch) move event
    const handlePointerMove = (event) => {
        event.stopPropagation();
        event.preventDefault();
        if (isRotating) {
        // If rotation is enabled, calculate the change in clientX position
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;

        // calculate the change in the horizontal position of the mouse cursor or touch input,
        // relative to the viewport's width
        const delta = (clientX - lastX.current) / viewport.width;

        // Update the island's rotation based on the mouse/touch movement
        islandRef.current.rotation.y += delta * 0.01 * Math.PI;

        // Update the reference for the last clientX position
        lastX.current = clientX;

        rotationSpeed.current = delta * 0.01 * Math.PI;
        }
    };

    // Handle keydown events
    const handleKeyDown = (event) => {
        if (event.key === "ArrowLeft") {
        if (!isRotating) {
            setIsRotating(true)
            lastPanelState.current = isPanelView;
        };
        setFinishedRotating(false);

        islandRef.current.rotation.y += 0.005 * Math.PI;
        rotationSpeed.current = 0.0125;
        } else if (event.key === "ArrowRight") {
        if (!isRotating) {
            setIsRotating(true)
            lastPanelState.current = isPanelView;
        };
        setFinishedRotating(false);

        islandRef.current.rotation.y -= 0.005 * Math.PI;
        rotationSpeed.current = -0.0125;
        }
        setIsPanelView(false);
    };

    // Handle keyup events
    const handleKeyUp = (event) => {
        if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
            setIsRotating(false);
            // Revert to the last panel state
            setIsPanelView(lastPanelState.current);
        }
    };

    useEffect(() => {
        // Add event listeners for pointer and keyboard events
        const canvas = gl.domElement;
        canvas.addEventListener("pointerdown", handlePointerDown);
        canvas.addEventListener("pointerup", handlePointerUp);
        canvas.addEventListener("pointermove", handlePointerMove);
        window.addEventListener("keydown", handleKeyDown);
        window.addEventListener("keyup", handleKeyUp);

        // Remove event listeners when component unmounts
        return () => {
        canvas.removeEventListener("pointerdown", handlePointerDown);
        canvas.removeEventListener("pointerup", handlePointerUp);
        canvas.removeEventListener("pointermove", handlePointerMove);
        window.removeEventListener("keydown", handleKeyDown);
        window.removeEventListener("keyup", handleKeyUp);
        };
    }, [gl, handlePointerDown, handlePointerUp, handlePointerMove]);

    
    const additionalRotation = 2 * Math.PI / 3;
    const rotation0 = [0, 4.7, 0];
    const rotation1 = [0,2.6,0]
    const rotation2 = [0,0.5,0];
    const rotations = [rotation0, rotation1, rotation2];
    useFrame(() => {
        const rotation = islandRef.current.rotation.y;
        const normalizedRotation =
            ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
        // If not rotating, apply damping to slow down the rotation (smoothly)
        if (!isRotating) {
            // Apply damping factor
            rotationSpeed.current *= dampingFactor;
    
            // Stop rotation when speed is very small
            if (Math.abs(rotationSpeed.current) < 0.001) {
                let targetRotation;
                rotationSpeed.current = 0;
                let minDifference = Number.MAX_VALUE;
                const currentRotation = normalizedRotation;
                rotations.forEach(rot => {
                    const difference = Math.abs(currentRotation - rot[1]);
                    if (difference < minDifference) {
                        minDifference = difference;
                        targetRotation = rot[1];
                    }
                });
    
                // Smoothly transition to the nearest obelisk
                let deltaRotation = targetRotation - currentRotation;
                // Ensure we take the shortest path to the target rotation
                if (deltaRotation > Math.PI) {
                    deltaRotation -= 2 * Math.PI;
                } else if (deltaRotation < -Math.PI) {
                    deltaRotation += 2 * Math.PI;
                }
                const transitionSpeed = deltaRotation * dampingFactor * 0.1; // Adjust transition speed as needed
                islandRef.current.rotation.y += transitionSpeed;
                // Check if the island has snapped back to one of the obelisks
                if (Math.abs(deltaRotation) < 0.01) {
                    setFinishedRotating(true);
                }
            } else {
                islandRef.current.rotation.y += rotationSpeed.current;
            }
        } else {
            // Determine the current stage based on the island's orientation
            switch (true) {
                case normalizedRotation >= 5.45 && normalizedRotation <= 5.85:
                    setCurrentStage(4);
                    break;
                case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
                    setCurrentStage(3);
                    break;
                case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
                    setCurrentStage(2);
                    break;
                case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
                    setCurrentStage(1);
                    break;
                default:
                    setCurrentStage(null);
            }
        }
    });

    // need to trigger stars to load on mount
    const [triggerUpdate, setTriggerUpdate] = useState(false);

    useEffect(() => {
        // Update the state to trigger a quick update
        setTriggerUpdate(true);
    }, []); // Empty dependency array to trigger only on mount

    return (
        <a.group ref = {islandRef} position={position} {...props}>
        <mesh
            castShadow
            receiveShadow
            geometry={nodes["C++_C++_0"].geometry}
            material={materials.material}
            position={[-22.328, 35.783, 23.904]}
            rotation={[-1.552, -0.186, -0.794]}
            scale={0.731}
        />
        <group
            position={[23.162, 42.464, 18.352]}
            rotation={[0.87, -0.082, -2.641]}
            scale={-43.935}
        >
            <group rotation={[Math.PI / 2, 0, 0]}>
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_10.geometry}
                material={materials.orejas_black}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_4001.geometry}
                material={materials.main_celeste}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_5001.geometry}
                material={materials.piel_material}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_6.geometry}
                material={materials.nariz}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_7.geometry}
                material={materials.dientes}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_8.geometry}
                material={materials.ojos}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Object_9.geometry}
                material={materials.pupila}
            />
            </group>
        </group>
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_4002.geometry}
            material={materials.Glow}
            position={[-19.611, 41.468, -24.23]}
            rotation={[-2.59, -0.599, 1.202]}
            scale={1.081}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Python_Python_0.geometry}
            material={materials.Python}
            position={[22.767, 42.973, -13.421]}
            rotation={[-1.247, 0.003, 2.536]}
            scale={0.792}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes["React-Logo_Material002_0"].geometry}
            material={materials["Material.002"]}
            position={[25.281, 98.99, -17.553]}
            rotation={[Math.PI, 0.804, Math.PI / 2]}
            scale={[4.835, 4.835, 6.51]}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Backdrop_Material001_0.geometry}
            material={materials["Material.001"]}
            position={[23.762, 98.99, -16.089]}
            rotation={[Math.PI, 0.804, Math.PI / 2]}
            scale={[30.597, 30.597, 6.51]}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.threejs.geometry}
            material={materials.Material_0}
            position={[-19.765, 96.45, -12.532]}
            rotation={[1.016, 0.871, -0.9]}
            scale={0.498}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Ethereum_3D_logoObject_0_lambert2_0.geometry}
            material={materials.lambert2}
            position={[33.182, 106.258, 27.55]}
            rotation={[-1.786, 0.033, 0.943]}
            scale={[0.03, 0.034, 0.038]}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_4003.geometry}
            material={materials.Orange}
            position={[-9.125, 94.81, 35.417]}
            rotation={[Math.PI / 2, 0, 0.155]}
            scale={7.571}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Object_5002.geometry}
            material={materials.Blue}
            position={[-9.125, 94.81, 35.417]}
            rotation={[Math.PI / 2, 0, 0.155]}
            scale={7.571}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Torus001.geometry}
            material={fabricMat}
        />

         {/* ObeliskCircle component */}
         <ObeliskCircle center={position} radius={obeliskRadius} scale={obeliskScale} isRotating={isRotating} initialRotation={obeliskRotation} isPanelView={isPanelView} finishedRotating={finishedRotating}/>
         <NightSky numStars={100}/>
        </a.group>
    );
}

export default Island;