/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { a } from "@react-spring/three"
import ObeliskCircle from './ObeliskCircle'; // Import the ObeliskCircle component
import coast from '../assets/textures/coast_sand_rocks_02_diff_2k.jpg'
import soil from '../assets/textures/excavated_soil_wall_diff_1k.jpg'
import container from '../assets/textures/green_metal_rust_diff_1k.jpg'
import fabric from '../assets/textures/splodges.png'
import beachBall from '../assets/textures/BeachBallColor.jpg'
import * as THREE from "three";


import islandScene from '../assets/3d/Background_noSurface.glb'
import { NightSky } from "./Stars";

// Preload textures
const textureCoast = new THREE.TextureLoader().load(coast);
const textureSoil = new THREE.TextureLoader().load(soil);
const textureContainer = new THREE.TextureLoader().load(container);
const textureFabric = new THREE.TextureLoader().load(fabric);
const textureBeachBall = new THREE.TextureLoader().load(beachBall);

// Create materials using preloaded textures
const beachBallMat = new THREE.MeshStandardMaterial({
    map: textureBeachBall,
    roughness: 0.2,
    metalness: 0.1
});
const fabricMat = new THREE.MeshStandardMaterial({
    map: textureFabric,
    roughness: 0,
    metalness: 1
});
const coastMat = new THREE.MeshStandardMaterial({
    map: textureCoast,
    roughness: 0.8,
    metalness: 0
});
const soilMat = new THREE.MeshStandardMaterial({
    map: textureSoil,
    roughness: 0.7,
    metalness: 1
});

const containerMat = new THREE.MeshStandardMaterial({
    map: textureContainer,
    roughness: 0.9,
    metalness: 0.5
});


const Island = ({ isRotating, position, setIsRotating, setCurrentStage, obeliskRotation, obeliskScale, obeliskRadius, ...props })  => {
    const islandRef = useRef();
    // Get access to the Three.js renderer and viewport
    const { gl, viewport } = useThree();
    const { nodes, materials } = useGLTF(islandScene);

    // Use a ref for the last mouse x position
    const lastX = useRef(0);
    // Use a ref for rotation speed
    const rotationSpeed = useRef(0);
    // Define a damping factor to control rotation damping
    const dampingFactor = 0.95;

    // Handle pointer (mouse or touch) down event
    const handlePointerDown = (event) => {
        event.stopPropagation();
        event.preventDefault();
        setIsRotating(true);

        // Calculate the clientX based on whether it's a touch event or a mouse event
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;

        // Store the current clientX position for reference
        lastX.current = clientX;
    };

    // Handle pointer (mouse or touch) up event
    const handlePointerUp = (event) => {
        event.stopPropagation();
        event.preventDefault();
        setIsRotating(false);
    };

    // Handle pointer (mouse or touch) move event
    const handlePointerMove = (event) => {
        event.stopPropagation();
        event.preventDefault();
        if (isRotating) {
        // If rotation is enabled, calculate the change in clientX position
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;

        // calculate the change in the horizontal position of the mouse cursor or touch input,
        // relative to the viewport's width
        const delta = (clientX - lastX.current) / viewport.width;

        // Update the island's rotation based on the mouse/touch movement
        islandRef.current.rotation.y += delta * 0.01 * Math.PI;

        // Update the reference for the last clientX position
        lastX.current = clientX;

        // Update the rotation speed
        rotationSpeed.current = delta * 0.01 * Math.PI;
        }
    };

    // Handle keydown events
    const handleKeyDown = (event) => {
        if (event.key === "ArrowLeft") {
        if (!isRotating) setIsRotating(true);

        islandRef.current.rotation.y += 0.005 * Math.PI;
        rotationSpeed.current = 0.0125;
        } else if (event.key === "ArrowRight") {
        if (!isRotating) setIsRotating(true);

        islandRef.current.rotation.y -= 0.005 * Math.PI;
        rotationSpeed.current = -0.0125;
        }
    };

    // Handle keyup events
    const handleKeyUp = (event) => {
        if (event.key === "ArrowLeft" || event.key === "ArrowRight") {
        setIsRotating(false);
        }
    };

    useEffect(() => {
        // Add event listeners for pointer and keyboard events
        const canvas = gl.domElement;
        canvas.addEventListener("pointerdown", handlePointerDown);
        canvas.addEventListener("pointerup", handlePointerUp);
        canvas.addEventListener("pointermove", handlePointerMove);
        window.addEventListener("keydown", handleKeyDown);
        window.addEventListener("keyup", handleKeyUp);

        // Remove event listeners when component unmounts
        return () => {
        canvas.removeEventListener("pointerdown", handlePointerDown);
        canvas.removeEventListener("pointerup", handlePointerUp);
        canvas.removeEventListener("pointermove", handlePointerMove);
        window.removeEventListener("keydown", handleKeyDown);
        window.removeEventListener("keyup", handleKeyUp);
        };
    }, [gl, handlePointerDown, handlePointerUp, handlePointerMove]);

    // This function is called on each frame update
    const additionalRotation = 2 * Math.PI / 3;
    const rotation0 = [0, 4.7, 0];
    const rotation1 = [0,2.6,0]
    const rotation2 = [0,0.5,0];
    const rotations = [rotation0, rotation1, rotation2];
    useFrame(() => {
        const rotation = islandRef.current.rotation.y;
        const normalizedRotation =
            ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
        
        // If not rotating, apply damping to slow down the rotation (smoothly)
        if (!isRotating) {
            // Apply damping factor
            rotationSpeed.current *= dampingFactor;
    
            // Stop rotation when speed is very small
            if (Math.abs(rotationSpeed.current) < 0.001) {
                let targetRotation;
                rotationSpeed.current = 0;
                let minDifference = Number.MAX_VALUE;
                const currentRotation = normalizedRotation;
                rotations.forEach(rot => {
                    const difference = Math.abs(currentRotation - rot[1]);
                    if (difference < minDifference) {
                        minDifference = difference;
                        targetRotation = rot[1];
                    }
                });
    
                // Smoothly transition to the nearest obelisk
                let deltaRotation = targetRotation - currentRotation;
                // Ensure we take the shortest path to the target rotation
                if (deltaRotation > Math.PI) {
                    deltaRotation -= 2 * Math.PI;
                } else if (deltaRotation < -Math.PI) {
                    deltaRotation += 2 * Math.PI;
                }
                const transitionSpeed = deltaRotation * dampingFactor * 0.1; // Adjust transition speed as needed
                islandRef.current.rotation.y += transitionSpeed;
            } else {
                islandRef.current.rotation.y += rotationSpeed.current;
            }
        } else {
            // Determine the current stage based on the island's orientation
            switch (true) {
                case normalizedRotation >= 5.45 && normalizedRotation <= 5.85:
                    setCurrentStage(4);
                    break;
                case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
                    setCurrentStage(3);
                    break;
                case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
                    setCurrentStage(2);
                    break;
                case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
                    setCurrentStage(1);
                    break;
                default:
                    setCurrentStage(null);
            }
        }
    });

    return (
        <a.group ref = {islandRef} position={position} {...props}>
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cube001.geometry}
            material={soilMat}
            position={[0.939, 5.95, 0]}
            rotation={[0.327, -0.326, 0.671]}
            scale={[1, 3.201, 1]}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Torus.geometry}
            material={fabricMat}
            position={[0.939, 3.692, 0]}
            rotation={[-Math.PI, 0, -Math.PI]}
            scale={[3.515, 5.87, 3.515]}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Sphere001.geometry}
            // material={nodes.Sphere001.material}
            material={beachBallMat}
            position={[-0.794, 15.814, 3.634]}
            scale={-3.473}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cylinder.geometry}
            material={coastMat}
            position={[3.77, 10.613, -0.948]}
            rotation={[-1.59, -0.682, -1.575]}
        />
        <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cone.geometry}
            material={fabricMat}
            position={[0.939, 12.96, -1.466]}
            rotation={[-1.206, 0.705, 1.038]}
            scale={1.069}
        />
         {/* ObeliskCircle component */}
         <ObeliskCircle center={position} radius={obeliskRadius} scale={obeliskScale} isRotating={isRotating} initialRotation={obeliskRotation}/>
         <NightSky numStars={200}/>
        </a.group>
    );
}

export default Island;